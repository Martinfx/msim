<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
	<title>MSIM Version 1.3.8.5 Reference Manual</title>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<link rel="stylesheet" type="text/css" href="default.css" />
</head>
<body>
<h1>MSIM Version 1.3.8.5 Reference Manual</h1>
<h2>Abstract</h2>

<p>The purpose of this document is to provide a comprehensive reference manual
for <a href="http://d3s.mff.cuni.cz/~holub/sw/msim/">MSIM</a> version 1.3.8.5.</p>

<p>&copy;&nbsp;2007 <a href="http://d3s.mff.cuni.cz/~holub/">Viliam Holub</a> (holub<emph class="ax1">+DELETE</emph><emph class="ax2">&#064;</emph>d3s.mff.cuni.cz)<br />
&copy;&nbsp;2010 <a href="http://d3s.mff.cuni.cz/~decky/">Martin Decky</a> (decky<emph class="ax1">+DELETE</emph><emph class="ax2">&#064;</emph>d3s.mff.cuni.cz)</p>

<h2>Last change</h2>

<p>2016-02-29</p>

<h2>Table of contents</h2>

<ul id="table_of_contents">
	<li><a href="#Introduction">1. Introduction</a><br />
		<ul>
			<li><a href="#Conventions">1.1. Conventions</a></li>
		</ul>
	</li>
	<li><a href="#Deployment">2. Deployment</a><br />
		<ul>
			<li><a href="#Downlaod">2.1. Download</a></li>
			<li><a href="#Configuration">2.2. Configuration</a></li>
			<li><a href="#Compilation">2.3. Compilation</a></li>
			<li><a href="#Installation">2.4. Installation</a></li>
		</ul>
	</li>
	<li><a href="#Command_line_parameters">3. Command line parameters</a><br />
		<ul>
			<li><a href="#cmd_version">3.1. Version <code>-V</code>, <code>--version</code></a></li>
			<li><a href="#cmd_configuration">3.2. Configuration file <code>-c</code>, <code>--config</code></a></li>
			<li><a href="#cmd_interactive">3.3. Interactive mode <code>-i</code>, <code>--interactive</code></a></li>
			<li><a href="#cmd_trace">3.4. Trace mode <code>-t</code>, <code>--trace</code></a></li>
			<li><a href="#cmd_gdb">3.5. GDB mode <code>-g</code>, <code>--remote-gdb</code></a></li>
		</ul>
	</li>
	<li><a href="#System_environment">4. System environment</a></li>
	<li><a href="#Configuration_file">5. Configuration file</a></li>
	<li><a href="#Internal_variables">6. Internal variables</a></li>
	<li><a href="#Input_command_line">7. Input command line</a></li>
	<li><a href="#System_commands">8. System commands</a><br />
		<ul>
			<li><a href="#System_list">8.1. List of system commands</a></li>
			<li><a href="#Add">8.2. Add <code>add</code></a></li>
			<li><a href="#Quit">8.3. Quit <code>quit</code></a></li>
			<li><a href="#Memory_dump">8.4. Memory dump <code>md</code></a></li>
			<li><a href="#Instruction_dump">8.5. Instruction dump <code>id</code></a></li>
			<li><a href="#Device_dump">8.6. Device dump <code>dd</code></a></li>
			<li><a href="#Memory_block_dump">8.7. Memory block dump <code>mbd</code></a></li>
			<li><a href="#Breakpoint">8.8. Add memory breakpoint <code>break</code></a></li>
			<li><a href="#Breakpoint_dump">8.9. Dump memory breakpoints <code>bd</code></a></li>
			<li><a href="#Breakpoint_remove">8.10. Remove memory breakpoint <code>br</code></a></li>
			<li><a href="#Statistics">8.11. Statistics <code>stat</code></a></li>
			<li><a href="#Print">8.12. Print <code>echo</code></a></li>
			<li><a href="#Goto">8.13. Continue <code>continue</code></a></li>
			<li><a href="#Step">8.14. Step <code>step</code></a></li>
			<li><a href="#Set">8.15. Set <code>set</code></a></li>
			<li><a href="#Unset">8.16. Unset <code>unset</code></a></li>
			<li><a href="#Help">8.17. Help <code>help</code></a></li>
		</ul>
	</li>
	<li><a href="#Devices">9. Devices</a><br />
		<ul>
			<li><a href="#Devices_list">9.1. List of devices<code></code></a></li>
			<li><a href="#dcpu">9.2. Processor <code>dcpu</code></a></li>
			<li><a href="#rwm">9.3. Read/write memory <code>rwm</code></a></li>
			<li><a href="#rom">9.4. Read-only memory <code>rom</code></a></li>
			<li><a href="#dprinter">9.5. Character output device <code>dprinter</code></a></li>
			<li><a href="#dkeyboard">9.6. Character input device <code>dkeyboard</code></a></li>
			<li><a href="#ddisk">9.7. Block device <code>ddisk</code></a></li>
			<li><a href="#dorder">9.8. Interprocessor communication device <code>dorder</code></a></li>
			<li><a href="#dtime">9.9. Real-time clock <code>dtime</code></a></li>
			</ul>
		</li>
	<li><a href="#Special_instructions">10. Special instructions</a></li>
		<ul>
			<li><a href="#dtrc">10.1. Trace on <code>DTRC</code></a></li>
			<li><a href="#dtro">10.2. Trace off <code>DTRO</code></a></li>
			<li><a href="#dint">10.3. Interactive mode on <code>DINT</code></a></li>
			<li><a href="#drv">10.4. Register view <code>DRV</code></a></li>
			<li><a href="#dhlt">10.5. Halt machine <code>DHLT</code></a></li>
			<li><a href="#dval">10.6. View value <code>DVAL</code></a></li>
		</ul>
	</li>
	<li><a href="#GDB_support">11. GDB support</a></li>
</ul>

<h2>1. Introduction<a name="Introduction"></a></h2>

<p>MSIM is a light-weight computer simulator based on MIPS R4000. It is used for
education and research purposes, mainly to teach the construction and
implementation of operating systems. MSIM is distributed with source code under
the GNU GPL license to make possible modifications for users and works on most
POSIX-compliance environments (mainly GNU/Linux, Mac&nbsp;OS&nbsp;X, but can be
also compiled in Cygwin or MinGW in Windows).</p>

<p>MSIM provides following features (along others):</p>

<ul>
	<li>MIPS R4000 CPU
		<ul>
			<li>full memory management (TLB)</li>
			<li>multiprocessor support</li>
			<li>the instruction set is restricted to 32 bits</li>
			<li>CPU cache is not simulated</li>
		</ul>
	</li>
	<li>simple debugging features (including disassembling, register content dump)</li>
	<li>several simple hardware devices</li>
	<li>various hardware-manipulating commands</li>
	<li>widely configurable memory mapping of devices</li>
	<li>script-like start-up configuration file</li>
</ul>

<p>MSIM does not aim to be a speed-optimized real hardware simulator, but rather
a fully deterministic simulator useful for kernel debugging. There are several
other projects which aim speed-optimized simulation (e.g. <a href="http://gavare.se/gxemul/">GXemul</a>),
but they are more complex to use.</p>

<p>Other hardware devices are designed in a very straightforward way to
emphatize basic principles of operation, but do not confuse the programmers
with historical heritage and complex issues.</p>

<p>There are several modes the MSIM runs in. Typically, the user will
simply configure the system and execute the code. For debugging purposes,
the simulation can be switched into <emph>trace mode</emph>, where all
executed instructions are displayed together with system events.
In <emph>interactive mode</emph> the user communicates with the simulator via
a command line interface and can modify the environment of the running
system.</p>

<p>MSIM is programmed in the C programming language. It is not specifically
designed to run on any architecture of the host computer and is thus very portable.
The design of the simulator is also modular and extensible. A simulator core
provides a common clock for all modules. The modules (or <emph>devices</emph>
in the MSIM terminology) implement a specific functionality such as the CPU,
keyboard input, character output, etc.</p>

<h3>1.1. Conventions<a name="Conventions"></a></h3>

<p>We use these typographic conventions throughout the text:</p>

<table>
	<tr><th>Type</th><th>Example</th></tr>
	<tr><td>Shell command line</td><td><pre class="cmd"><strong>$</strong> command</pre></td></tr>
	<tr><td>MSIM command line</td><td><pre class="cmd"><strong>[msim]</strong> command</pre></td></tr>
	<tr><td>Source code</td><td>
<pre class="c"><span class="lnr">  1 </span><span class="comment">/* This is just a comment. */</span>
<span class="lnr">  2 </span>
<span class="lnr">  3 </span><span class="preproc">#define MACRO something</span>
<span class="lnr">  4 </span>
<span class="lnr">  5 </span><span class="keyword">int</span> fnc(<span class="keyword">int</span> variable)
<span class="lnr">  6 </span>{
<span class="lnr">  7 </span>    <span class="keyword">if</span> (variable > 0)
<span class="lnr">  8 </span>        <span class="keyword">return</span> 1;
<span class="lnr">  9 </span>    
<span class="lnr"> 10 </span>    <span class="keyword">return</span> fnc2(MACRO);
<span class="lnr"> 11 </span>}</pre></td></tr>
	<tr><td>Inline code</td><td>An example of <code>code</code> inside the text.</td></tr>
	<tr><td>Emphasized inline code</td><td>An example of an <code><strong>emphasized</strong> code</code> inside the text.</td></tr>
	<tr><td>Keyboard keys</td><td>When you should press the Enter key, <span class="key">Enter</span> is used.</td></tr>
</table>

<h2>2. Deployment<a name="Deployment"></a></h2>

<p>A POSIX compliant environment is required for MSIM to be compiled and
executed. It has been succesfully tested on GNU/Linux in various distributions
(Debian, Feroda, Gentoo) and platforms (x86, AMD64, UltraSPARC, PowerPC).
MSIM also runs in Solaris, OpenSolaris, FreeBSD and Mac&nbsp;OS&nbsp;X.</p>

<p>Under Windows MSIM can be compiled and executed in Cygwin or using MinGW/MSYS
as a natine Win32 console application (although the functionality might be
somehow limited).</p>

<p>A standard toolchain of consisting of a C compiler (preferably GCC) and
usual utilities (Bash, GNU Make) are the prerequisites for building MSIM.
The <a href="http://tiswww.tis.case.edu/~chet/readline/rltop.html">GNU Readline</a>
library is also required.</p>

<h3>2.1. Download<a name="Download"></a></h3>

<p>The current version of MSIM can be downloaded from the
<a href="http://d3s.mff.cuni.cz/~holub/sw/msim/">project site</a>. It is
distributed via a source tarball. Untar the distribution package
and change your current directory to the directory containing a script
called <code>configure</code>.</p>

<p>A usual way of downloading and extracting the source package package is:</p>

<pre class="cmd"><strong>$</strong> wget http://d3s.mff.cuni.cz/~holub/sw/msim/msim-1.3.8.5.tar.bz2<span class="key">Enter</span>
<strong>...</strong>
<strong>$</strong> tar -xjf msim-1.3.8.5.tar.bz2<span class="key">Enter</span>
<strong>$</strong> cd msim-1.3.8.5<span class="key">Enter</span></pre>

<h3>2.2. Configuration<a name="Configuration"></a></h3>

<p>To configure the package for compilation use the <code>configure</code>
scripts. The script should detect all important compilation options
and check for prerequisites.</p>

<p>Specific options to the <code>configure</code> script can be used,
e.g. <code>--prefix=</code> to set the installation prefix.</p>

<pre class="cmd"><strong>$</strong> ./configure --prefix=/opt</pre>

<h3>2.3. Compilation<a name="Compilation"></a></h3>

<p>After a succesful execution of <code>configure</code> just run
<code>make</code> to compile the sources. No special arguments
are usually necessary.</p>

<pre class="cmd"><strong>$</strong> make</pre>

<h3>2.4. Installation<a name="Installation"></a></h3>

<p>If the compilation is succesful, you can use the following command
to install the binary and sumplementary files into the installation
prefix. You will probably need root privileges to install MSIM
into system-wide prefix.</p>

<pre class="cmd"><strong>#</strong> make install</pre>

<h2>3. Command line parameters<a name="Command_line_parameters"></a></h2>

<p>This section briefly describes the command line parameters of MSIM. Most
of the parameters can be combined. For example a typical usage is to use
the combination <code>-i -t</code> to enter both interactive and trace
mode on startup.</p>

<h3>3.1. Version <code>-V</code>, <code>--version</code><a name="cmd_version"></a></h3>

<h4>Synopsis</h4>
<p>Display MSIM version information and quit.</p>
<h4>Example</h4>
<pre class="cmd"><strong>$</strong> msim -V<span class="key">Enter</span>
MSIM version 1.3.8.5
copyright (c) 2000-2016 Viliam Holub, Martin Decky</pre>

<h3>3.2. Configuration file <code>-c</code>, <code>--config</code><a name="cmd_configuration"></a></h3>

<h4>Synopsis</h4>
<p>Specify the configuration file name which overrides the default searching
rules.</p>
<h4>Syntax <code><strong>-c</strong>|<strong>--config</strong>[=]filename</code></h4>
<h4>Example</h4>
<pre class="cmd"><strong>$</strong> msim -c my.conf</pre>

<h3>3.3. Interactive mode <code>-i</code>, <code>--interactive</code><a name="cmd_interactive"></a></h3>

<h4>Synopsis</h4>
<p>The simulator enters the interactive mode immediately after the configuration file has been processed.</p>
<h4>Example</h4>
<pre class="cmd"><strong>$</strong> msim -i<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<h3>3.4. Trace mode <code>-t</code>, <code>--trace</code><a name="cmd_trace"></a></h3>

<h4>Synopsis</h4>
<p>Enter the trace mode, but does not enable the interactive mode.</p>
<h4>Example</h4>
<pre class="cmd"><strong>$</strong> msim -t<span class="key">Enter</span>
 1  BFC00000    lui   a0, 0x8000        # 0x8000=32768, a0: 0x0->0x80000000
 0  BFC00000    lui   a0, 0x8000        # 0x8000=32768, a0: 0x0->0x80000000
 1  BFC00004    ori   a0, a0, 0x1000    # 0x1000h=4096, a0: 0x80000000->0x80001000
 0  BFC00004    ori   a0, a0, 0x1000    # 0x1000h=4096, a0: 0x80000000->0x80001000
 1  BFC00008    sw    0, (a0)
 0  BFC00008    sw    0, (a0)

<strong>...</strong></pre>

<h3>3.5. GDB mode <code>-g</code>, <code>--remote-gdb</code><a name="cmd_gdb"></a></h3>

<h4>Synopsis</h4>
<p>Enter the GDB mode which allows a MIPS GDB to be connected to the running
MSIM for remote debugging. The GDB mode is rather experimental in version 1.3.8.5.</p>
<h4>Syntax: <code><strong>-g</strong>|<strong>--remote-gdb[=]</strong>port_number</code></h4>

<h3>3.6. Help <code>-h</code>, <code>--help</code><a name="cmd_help"></a></h3>

<h4>Synopsis</h4>
<p>Print command line help and quit.</p>

<h2>4. System environment<a name="System_environment"></a></h2>

<p>When no configuration file <code>msim.conf</code> exists in the current
directory (and no other configuration file is specified via the <code>-c</code>
command line parameter), the simulator represents and &quot;empty computer&quot;
after startup. In this case MSIM will go into interactive mode.</p>

<p>By default, there are no hardware devices configured, there is no physical
memory, there is not even a CPU for running code. Just the MSIM command line
prompt can be seen:</p>

<pre class="cmd"><strong>[msim]</strong> </pre>

<p>You have to use the <a href="#System_commands">system commands</a> to
configure the environment. Here is a reasonable minimal set of commands
which are required to execute some MIPS code:</p>

<pre class="cmd"><strong>[msim]</strong> add dcpu cpu0<span class="key">Enter</span>
<strong>[msim]</strong> add rwm memory 0x00000000<span class="key">Enter</span>
<strong>[msim]</strong> memory generic 16M<span class="key">Enter</span>
<strong>[msim]</strong> add rom firmware 0x1fc00000<span class="key">Enter</span>
<strong>[msim]</strong> firmware generic 4096k<span class="key">Enter</span>
<strong>[msim]</strong> firmware load "firmware.img"<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<p>This will configure the environment with the following devices:</p>

<ul>
	<li>a single CPU (called <code>cpu0</code>)</li>
	<li>a piece of read/write memory starting at the physical address 0x00000000
		and with the size of 16&nbsp;MB (called <code>memory</code>)</li>
	<li>a piece of read-only memory starting at the physical address 0x1fc00000
		and with the size of 4096&nbsp;KB (called <code>firmware</code>)
		<ul>
			<li>this read-only memory is populated with the contents of the file
				<code>firmware.img</code> (this file must exist it the current
				directory of the host computer)</li>
		</ul>
	</li>
</ul>

<p>After this basic configuration the simulator is ready to execute the
code (sequence of MIPS instructions) loaded from the file <code>firmware.img</code>
and stored in the <code>firmware</code> read-only memory. The single CPU configured
in the system (<code>cpu0</code>) will start the execution at the virtual address
0xbfc00000, which exactly corresponds to the physical address 0x1fc00000 (i.e.
the start of <code>firmware</code> memory).</p>

<p>The executed code will be able to use the read/write memory <code>memory</code>
located at the physical address 0x00000000. The execution environment is modeled
strictly according to the specification of MIPS R4000 CPU (please refer to
<emph>MIPS R4000 Microprocessor User's Manual</emph>).</p>

<p>Please refer also to further sections of this text for details about the
commands used in our brief example.</p>

<h2>5. Configuration file<a name="Configuration_file"></a></h2>

<p>The configuration file of MSIM (usually called <code>msim.conf</code>)
contains any system commands which would be otherwise typed in interactive
mode in MSIM prompt. This allows for maximum flexibility and ease of use
as you don't have to learn to use the set of commands for the interactive
mode and another set of commands for the use in the configuration file.</p>

<p>A typical <code>msim.conf</code> might look like this:</p>

<pre class="c"><span class="lnr">  1 </span><span class="comment">#</span>
<span class="lnr">  2 </span><span class="comment"># MSIM configuration script</span>
<span class="lnr">  3 </span><span class="comment">#</span>
<span class="lnr">  4 </span>
<span class="lnr">  5 </span><span class="keyword">add</span> dcpu <span class="preproc">cpu0</span>
<span class="lnr">  6 </span><span class="keyword">add</span> dcpu <span class="preproc">cpu1</span>
<span class="lnr">  7 </span>
<span class="lnr">  8 </span><span class="keyword">add</span> rwm <span class="preproc">mainmem</span> 0x00000000
<span class="lnr">  9 </span><span class="preproc">mainmem</span> <span class="keyword">generic</span> 16M
<span class="lnr"> 10 </span><span class="preproc">mainmem</span> <span class="keyword">load</span> "/dev/zero"
<span class="lnr"> 11 </span>
<span class="lnr"> 12 </span><span class="keyword">add</span> rom <span class="preproc">bootmem</span> 0x1fc00000
<span class="lnr"> 13 </span><span class="preproc">bootmem</span> <span class="keyword">generic</span> 4096k
<span class="lnr"> 14 </span><span class="preproc">bootmem</span> <span class="keyword">load</span> "image.boot"
<span class="lnr"> 15 </span>
<span class="lnr"> 16 </span><span class="keyword">add</span> dprinter <span class="preproc">printer</span> 0x10000000
<span class="lnr"> 17 </span><span class="keyword">add</span> dkeyboard <span class="preproc">keyboard</span> 0x10000000 2
<span class="lnr"> 18 </span><span class="keyword">add</span> dorder <span class="preproc">order</span> 0x10000004 5</pre>

<p>Similarily to shell scripts empty lines are ignored. Also any text beginning
with the <code>#</code> character to the end of the line is considered a comment
and is ignored.</p>

<h2>6. Internal variables<a name="Internal_variables"></a></h2>

<p>MSIM defines several internal variables which control its behaviour
during execution. The variables can be set via the <a href="#Set">set</a>
and unset via the <a href="#Unset">unset</a> commands. Following internal
variables are available:</p>

<dl>
	<dt><a href="#trace">trace</a></dt>
		<dd>Enable trace mode</dd>
	<dt><a href="#iaddr">iaddr</a></dt>
		<dd>Enable addresses in disassembler</dd>
	<dt><a href="#iopc">iopc</a></dt>
		<dd>Enable opcodes in disassembler</dd>
	<dt><a href="#icmt">icmt</a></dt>
		<dd>Enable additional comments (such as number conversions) in disassembler</dd>
	<dt><a href="#iregch">iregch</a></dt>
		<dd>Show register changes in disassembler</dd>
	<dt><a href="#ireg">ireg</a></dt>
		<dd>Set type of register names</dd>
</dl>

<p>The following table and examples demonstrate how the various variables
affect the fields which are printed in disassembler.</p>

<table>
	<caption>Instruction disassembling overview</caption>
	<tr>
		<td></td>
		<th>Address</th>
		<th>Opcode</th>
		<th>Instruction</th>
		<th>Conversion</th>
		<th>Changes</td>
	</tr>
	<tr>
		<th>Variable</th>
		<td><code>iaddr</code></td>
		<td><code>iopc</code></td>
		<td><code>ireg</code></td>
		<td><code>icmt</code></td>
		<td><code>iregch</code></td>
	</tr>
	<tr>
		<th>Sample output</th>
		<td><code>80000F04</code>&nbsp;</td>
		<td><code>24840100</code>&nbsp;&nbsp;</td>
		<td><code>addiu a0, a0, 0x100</code>&nbsp;&nbsp;</td>
		<td><code># 0x100=256</code></td>
		<td><code>, a0: 0x4-&gt;0x104</code></td>
	</tr>
</table>

<p>Addresses in disassebler:</p>

<pre class="cmd"><strong>[msim]</strong> unset iaddr<span class="key">Enter</span>
<strong>[msim]</strong> id 0x0040121c 1<span class="key">Enter</span>
      lw    a0, 0x1694(gp)    # 0x1694=5780
<strong>[msim]</strong> set iaddr<span class="key">Enter</span>
<strong>[msim]</strong> id 0x0040121c 1<span class="key">Enter</span>
    0040121C    lw    a0, 0x1694(gp)    # 0x1694=5780
<strong>[msim]</strong> </pre>

<p>Opcodes in disassembler:</p>

<pre class="cmd"><strong>[msim]</strong> unset iopc<span class="key">Enter</span>
<strong>[msim]</strong> id 0x0040121c 1<span class="key">Enter</span>
    0040121C    lw    a0, 0x1694(gp)    # 0x1694=5780
<strong>[msim]</strong> set iopc<span class="key">Enter</span>
<strong>[msim]</strong> id 0x0040121c 1<span class="key">Enter</span>
    0040121C  8F841694    lw    a0, 0x1694(gp)    # 0x1694=5780
<strong>[msim]</strong> </pre>

<p>Additional disassembler information (e.g. hex to decimal number conversions):</p>

<pre class="cmd"><strong>[msim]</strong> unset icmt<span class="key">Enter</span>
<strong>[msim]</strong> id 0x00400ef8 1<span class="key">Enter</span>
    00400EF8    sw    a0, 0x1694(gp)
<strong>[msim]</strong> set icmt<span class="key">Enter</span>
<strong>[msim]</strong> id 0x00400ef8 1<span class="key">Enter</span>
    00400EF8    sw    a0, 0x1694(gp)    # 0x1694=5780
<strong>[msim]</strong> </pre>

<p>Register changes in disassembler:</p>

<pre class="cmd"><strong>[msim]</strong> unset iregch<span class="key">Enter</span>
<strong>[msim]</strong> s 5<span class="key">Enter</span>
    0  80400ECC    addu  v0, v0, a1
    0  80400ED0    sll   v0, v0, 0x06
    0  80400ED4    subu  v0, v0, a1
    0  80400ED8    sll   v1, v0, 0x02
    0  80400EDC    addu  v0, v0, v1
<strong>[msim]</strong> set iregch<span class="key">Enter</span>
<strong>[msim]</strong> s 5<span class="key">Enter</span>
    0  80400EE0    sll   v0, v0, 0x04      # v0: 0xe12018d9-&gt;0xe83550, 
                                           # v1: 0xe03fd900-&gt;0xb9c44, 
                                           # a0: 0x6d9b-&gt;0xe9e3a6c0, 
                                           # a1: 0xa9-&gt;0xaf, a2: 0xda-&gt;0xdb, 
                                           # loreg: 0x394745fa-&gt;0x7844ddc0, 
                                           # hireg: 0x7116dba5-&gt;0x7544c9eb
    0  80400EE4    addu  v0, v0, a1        # v0: 0xe83550-&gt;0xe835ff
    0  80400EE8    sll   v1, v0, 0x08      # v1: 0xb9c44-&gt;0xe835ff00
    0  80400EEC    addu  v0, v0, v1        # v0: 0xe835ff-&gt;0xe91e34ff
    0  80400EF0    subu  a0, a0, v0        # a0: 0xe9e3a6c0-&gt;0xc571c1
<strong>[msim]</strong> </pre>

<p>The <code>ireg</code> selects the scheme for register names used by the
disassembler:</p>

<table>
	<caption>Basic processor registers</caption>
	<tr>
		<th><code>ireg</code></td>
		<th>Description</th>
		<th>List of register names</th>
	</tr>
	<tr>
		<td>0</td>
		<td>Processor-oriented</td>
		<td>r0 r1 r2 r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 r16 r17 r18 r19 r20 r21 r22 r23 r24 r25 r26 r27 r28 r29 r30 r31</td>
	</tr>
	<tr>
		<td>1</td>
		<td>AT&amp;T assembler</td>
		<td>$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $20 $21 $22 $23 $24 $25 $26 $27 $28 $29 $30 $31</td>
	</tr>
	<tr>
		<td>2</td>
		<td>Compiler convention</td>
		<td>0 at v0 v1 a0 a1 a2 a3 t0 t1 t2 t3 t4 t5 t6 t7 s0 s1 s2 s3 s4 s5 s6 s7 t8 t9 k0 k1 gp sp fp ra</td>
	</tr>
</table>

<table>
	<caption>CP0 registers</caption>
	<tr>
		<th><code>ireg</code></td>
		<th>Description</th>
		<th>List of register names</th>
	</tr>
	<tr>
		<td>0</td>
		<td>Processor-oriented</td>
		<td>0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31</td>
	</tr>
	<tr>
		<td>1</td>
		<td>AT&amp;T assembler</td>
		<td>$0 $1 $2 $3 $4 $5 $6 $7 $8 $9 $10 $11 $12 $13 $14 $15 $16 $17 $18 $19 $20 $21 $22 $23 $24 $25 $26 $27 $28 $29 $30 $31</td>
	</tr>
	<tr>
		<td>2</td>
		<td>Compiler convention</td>
		<td>index random entrylo0 entrylo1 context pagemask wired res_7 badvaddr count entryhi compare status cause epc prid config lladdr watchlo watchhi xcontext res_21 res_22 res_23 res_24 res_25 res_26 res_27 res_28 res_29 errorepc res_31</td>
	</tr>
</table>

<p>Sample of usage:</p>

<pre class="cmd"><strong>[msim]</strong> set ireg=0<span class="key">Enter</span>
<strong>[msim]</strong> id 0x00400efc 4<span class="key">Enter</span>
    00400EFC    srl   r4, r4, 0x08
    00400F00    andi  r4, r4, 0x000f    # 0xfh=15
    00400F04    addiu r4, r4, 0x100     # 0x100=256
    00400F08    sltu  r4, r6, r4
<strong>[msim]</strong> set ireg=1<span class="key">Enter</span>
<strong>[msim]</strong> id 0x00400efc 4<span class="key">Enter</span>
    00400EFC    srl   $4, $4, 0x08
    00400F00    andi  $4, $4, 0x000f    # 0xfh=15
    00400F04    addiu $4, $4, 0x100     # 0x100=256
    00400F08    sltu  $4, $6, $4
<strong>[msim]</strong> set ireg=2<span class="key">Enter</span>
<strong>[msim]</strong> id 0x00400efc 4<span class="key">Enter</span>
    00400EFC    srl   a0, a0, 0x08
    00400F00    andi  a0, a0, 0x000f    # 0xfh=15
    00400F04    addiu a0, a0, 0x100     # 0x100=256
    00400F08    sltu  a0, a2, a0
<strong>[msim]</strong> </pre>

<p>The <code>trace</code> variable switches the simulator into the trace mode.
In trace mode, all the executed instructions are disassembled and immediately
displayed on the screen.</p>

<pre class="cmd"><strong>[msim]</strong> unset trace<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
<strong>[msim]</strong> set trace<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
    0  80400EC8    sll   v0, a1, 0x04      # v0: 0x1fcec0c2-&gt;0x2f0, 
                                          # a1: 0x1ffc0227-&gt;0x2f
<strong>[msim]</strong> s<span class="key">Enter</span>
    0  80400ECC    addu  v0, v0, a1        # v0: 0x2f0-&gt;0x31f
<strong>[msim]</strong> s<span class="key">Enter</span>
    0  80400ED0    sll   v0, v0, 0x06      # v0: 0x31f-&gt;0xc7c0
<strong>[msim]</strong> </pre>

<h2>7. Input command line<a name="Input_command_line"></a></h2>

<p>The command line support various nice features like command history, tab
completion for completing the commands and arguments while typing, etc.</p>

<p>A very brief overview of the input command line properties:</p>

<ul>
	<li>Commands and their arguments are separated via whitespace. Whitespace
		characters are: space, tab, period.</li>
	<li>Numeric values can be prefixed by <code>0x</code> representing hexadecimal
		notation.</li>
	<li>Numeric values can be suffixed by <code>k</code> and <code>K</code>
		(representing multiplication by 1024 or 1000) and <code>M</code> (representing
		multiplication by 1048576).</li>
	<li>String values should be surrounded by quotes (as
		in <code>&quot;abcd&quot;</code>).</li>
</ul>

<h2>8. System commands<a name="System_commands"></a></h2>

<p>This section describes the commands of MSIM. These commands can be used
either in the interactive mode or in a configuration file.</p>

<h3>8.1. List of system commands<a name="System_list"></a></h3>

<dl>
	<dt><a href="#Add">add</a></dt>
		<dd>Add a new device into the system.</dd>
	<dt><a href="#Quit">quit</a></dt>
		<dd>Exit MSIM.</dd>
	<dt><a href="#Memory_dump">md</a></dt>
		<dd>Dump words from unmapped memory.</dd>
	<dt><a href="#Instruction_dump">id</a></dt>
		<dd>Dump instructions from unmapped memory.</dd>
	<dt><a href="#Device_dump">dd</a></dt>
		<dd>Dump all installed devices.</dd>
	<dt><a href="#Memory_block_dump">mbd</a></dt>
		<dd>Dump all installed memory blocks.</dd>
	<dt><a href="#Breakpoint">break</a></dt>
		<dd>Add memory breakpoint.</dd>
	<dt><a href="#Breakpoint_dump">bd</a></dt>
		<dd>Dump memory breakpoints.</dd>
	<dt><a href="#Breakpoint_remove">br</a></dt>
		<dd>Remove memory breakpoint.</dd>
	<dt><a href="#Statistics">stat</a></dt>
		<dd>Dump available statistic information.</dd>
	<dt><a href="#Print">echo</a></dt>
		<dd>Print user message.</dd>
	<dt><a href="#Continue">Continue</a></dt>
		<dd>Continue simulaton.</dd>
	<dt><a href="#Step">step</a></dt>
		<dd>Simulate one or a specified number of instructions.</dd>
	<dt><a href="#Set">set</a></dt>
		<dd>Set environment variable.</dd>
	<dt><a href="#Unset">unset</a></dt>
		<dd>Unset environment variable.</dd>
	<dt><a href="#Help">help</a></dt>
		<dd>Display a help text.</dd>
</dl>

<h3>8.2. Add <code>add</code><a name="Add"></a></h3>
<h4>Synopsis</h4>
<p>Add a new device into the system under a specified name.</p>
<h4>Syntax <code><strong>add</strong> device_type device_name [device_parameters...]</code></h4>
<p>where</p>
<dl>
	<dt><code>device_type</code></dt>
		<dd>Specifies a device type. The list of available device types is in the <a href="#Devices">Devices</a> section.</dd>
	<dt><code>device_name</code></dt>
		<dd>An identifier of the newly created device. The name must not be equal to a system command and must be unique among already added devices.</dd>
	<dt><code>device_parameters</code></dt>
		<dd>Initial device parameters. The actual parameters depends on the device type.</dd>
</dl>
<h4>Example</h4>
<p>The first example adds a new printer <code>p0</code> to the system. The printer register is located at physical address 0x0001000.</p>
<pre class="cmd"><strong>[msim]</strong> add dprinter p0 0x1000<span class="key">Enter</span>
<strong>[msim]</strong> </pre>
<p>The second example adds a read-only memory <code>m0</code> mapped at physical address 0x00010000. The size of the memory is 16&nbsp;KB.</p>
<pre class="cmd"><strong>[msim]</strong> add rom m0 0x10000 16k<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<h3>8.3. Quit <code>quit</code><a name="Quit"></a></h3>
<h4>Synopsis</h4>
<p>Quit the simulator immediately.</p>

<h3>8.4. Memory dump <code>md</code><a name="Memory_dump"></a></h3>
<h4>Synopsis</h4>
<p>Print a part of a memory from an unmapped address.</p>
<h4>Syntax <code><strong>md</strong> address count</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Starting address of the memory block.</dd>
	<dt><code>count</code></dt>
		<dd>Number of words to print.</dd>
</dl>
<h4>Example</h4>
<p>The following example prints 10 words from the physical address 0x00001240.</p>
<pre class="cmd"><strong>[msim]</strong> md 0x1240 10<span class="key">Enter</span>
  00001240    265a45cd  2fefe111  11deadee  30957311  
  00001250    7b218f9f  ffff2345  baba5555  deadbeaf  
  00001260    29dc9aff  1298aa23
<strong>[msim]</strong> </pre>

<h3>8.5. Instruction dump <code>id</code><a name="Instruction_dump"></a></h3>
<h4>Synopsis</h4>
<p>Print disassembled instructions from the specified unmapped address.</p>
<h4>Syntax <code><strong>id</strong> address count</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Starting address of the memory block.</dd>
	<dt><code>count</code></dt>
		<dd>Number of instructions to print.</dd>
</dl>
<h4>Example</h4>
<p>The following example prints 10 instructions from the address 0x000012a8.</p>
<pre class="cmd"><strong>[msim]</strong> id 0x12a8 10<span class="key">Enter</span>
    000012A8    ori   s0, s0, 0x5427    # 0x5427h=21543
    000012AC    sw    s2, 0x18(sp)      # 0x18=24
    000012B0    lui   s2, 0x805a        # 0x805a=32858
    000012B4    ori   s2, s2, 0xce55
    000012B8    sw    s1, 0x14(sp)      # 0x14=20
    000012BC    lui   s1, 0x8100        # 0x8100=33024
    000012C0    sw    ra, 0x1c(sp)      # 0x1c=28
    000012C4    lw    a0, 0x1640(gp)    # 0x1640=5696
    000012C8    jal   +0x4009d4         # 0x4009d4=4196820
    000012CC    nop
<strong>[msim]</strong> </pre>

<h3>8.6. Device dump <code>dd</code><a name="Device_dump"></a></h3>
<h4>Synopsis</h4>
<p>Print a list of devices with parameters configured in the environment.</p>
<h4>Example</h4>
<p>The following example prints all devices in the system.</p>
<pre class="cmd"><strong>[msim]</strong> dd<span class="key">Enter</span>
[  name  ] [  type  ] [ parameters...
printer    dprinter   address:0x01000000
startmem   rom        start:0x1fc00000 size:1k type:mem
xxx        rwm        start:0x00400000 size:256k type:mem
mainmem    rwm        start:0x00000000 size:256k type:mem
mips1      dcpu       type:R4000.32
<strong>[msim]</strong> </pre>

<h3>8.7. Memory block dump <code>mbd</code><a name="Memory_block_dump"></a></h3> 
<h4>Synopsis</h4>
<p>Print all configured memory blocks.</p>
<h4>Example</h4>
<p>The following example prints all installed memory blocks.</p>
<pre class="cmd"><strong>[msim]</strong> mbd<span class="key">Enter</span>
[  name  ] [  type  ] [ parameters...
startmem   rom        start:0x1fc00000 size:1k type:mem
xxx        rwm        start:0x00400000 size:256k type:mem
mainmem    rwm        start:0x00000000 size:256k type:mem
<strong>[msim]</strong> </pre>

<h3>8.8. Add memory breakpoint <code>break</code><a name="Breakpoint"></a></h3>
<h4>Synopsis</h4>
<p>Add memory access breakpoint. If a read or write access on the the
physical address of the breakpoint occurs, the simulator is immediately
switched to interactive mode.</p>
<h4>Syntax <code><strong>break</strong> address type</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Address of the breakpoint.</dd>
	<dt><code>count</code></dt>
		<dd>Consider read accesses (<code>r</code>), write accesses (<code>w</code>) or both (<code>rw</code>).</dd>
</dl>

<h3>8.9. Dump memory breakpoints <code>bd</code><a name="Breakpoint_dump"></a></h3> 
<h4>Synopsis</h4>
<p>Print all configured memory access breakpoints.</p>

<h3>8.10. Remove memory breakpoint <code>br</code><a name="Breakpoint_remove"></a></h3> 
<h4>Synopsis</h4>
<p>Remove previously configured memory breakpoint.</p>
<h4>Syntax <code><strong>break</strong> address</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Address of the previously configured breakpoint.</dd>
</dl>

<h3>8.11. Statistics <code>stat</code><a name="Statistics"></a></h3>
<h4>Synopsis</h4>
<p>Print statistics of installed devices.</p>
<h4>Example</h4>
<p>The following example prints the statistics of all the installed devices.</p>
<pre class="cmd"><strong>[msim]</strong> stat<span class="key">Enter</span>
[  name  ] [  type  ] [ statistics...
printer    dprinter   count:42248
startmem   rom        no statistics
xxx        rwm        no statistics
mainmem    rwm        no statistics
mips1      dcpu       cycles total:1373061 in kernel:1373061 in user:0
                      in stdby:0 tlb refill:0 invalid: 0 modified:0
                      interrupts 0:0 1:0 2:0 3:0 4:0 5:0 6:0 7:0
<strong>[msim]</strong> </pre>

<h3>8.12. Print <code>echo</code><a name="Print"></a></h3>
<h4>Synopsis</h4>
<p>Print user message. The <code>echo</code> command is usually used for debugging purposes, mainly in the configuration file.</p>
<h4>Syntax <code><strong>echo</strong> message</code></h4>
<p>where</p>
<dl>
	<dt><code>message</code></dt>
		<dd>String which will be printed.</dd>
</dl>
<h4>Example</h4>
<p>The following example prints the message &quot;The point A has been reached&quot;.</p>
<pre class="cmd"><strong>[msim]</strong> echo "The point A has been reached"<span class="key">Enter</span>
The point A has been reached
<strong>[msim]</strong></pre>

<h3>8.13. Continue <code>continue</code><a name="Continue"></a></h3>
<h4>Synopsis</h4>
<p>Continue in the simulation. The interactive mode is leaved.</p>
<h4>Example</h4>
<p>In the following example, the execution is terminated by pressing
<span class="key">Ctrl+C</span> and later restarted by the <code>continue</code>
command. The trace mode in still on:</p>
<pre class="cmd"><strong>...</strong>

 0  80400ED4    subu  v0, v0, a1        # v0: 0x24640-&gt;0x245b7
 0  80400ED8    sll   v1, v0, 0x02      # v1: 0xb71d6a00-&gt;0x916dc<span class="key">Ctrl+C</span>

<strong>[msim]</strong> continue<span class="key">Enter</span>
 0  80400EDC    addu  v0, v0, v1        # v0: 0x245b7-&gt;0xb5c93
 0  80400EE0    sll   v0, v0, 0x04      # v0: 0xb5c93-&gt;0xb5c930
 0  80400EE4    addu  v0, v0, a1        # v0: 0xb5c930-&gt;0xb5c9b9

<strong>...</strong></pre>

<h3>8.14. Step <code>step</code><a name="Step"></a></h3>
<h4>Synopsis</h4>
<p>Execute one or a specified number of cycles. The <code>step</code> command is default
(it is executed if a blank command line entered).</p>
<h4>Snytax <code><strong>step</strong> [count]</code></h4>
<p>where</p>
<dl>
	<dt><code>count</code></dt>
		<dd>Optional number of cycles to execute.</dd>
</dl>
<h4>Example</h4>
<p>In the following example, the user executes 3 steps on a 2-processor machine:</p>
<pre class="cmd"><strong>[msim]</strong> s 3<span class="key">Enter</span>
 1  80400ACC    mfc0  v0, status        # v0: 0x0-&gt;0x8001
 0  80400EC4    srl   a1, a1, 0x18      # 0x18=24, a1: 0x6538b04f-&gt;0x65
 1  80400AD0    addiu v1, 0, 0xfffe     # v1: 0x0-&gt;0xfffffffe
 0  80400EC8    sll   v0, a1, 0x04      # v0: 0x219dad69-&gt;0x650
 1  80400AD4    and   v0, v0, v1        # v0: 0x8001-&gt;0x8000
 0  80400ECC    addu  v0, v0, a1        # v0: 0x650-&gt;0x6b5
<strong>[msim]</strong> </pre>

<h3>8.15. Set <code>set</code><a name="Set"></a></h3>
<h4>Synopsis</h4>
<p>Set an internal variable on or to a specified value or print a list of all variables.</p>
<h4>Syntax <code><strong>set</strong> [variable [= value]]</code></h4>
<p>where</p>
<dl>
	<dt><code>variable</code></dt>
		<dd>Name of the internal variable name to be set (if not specified, list of all variables is printed).</dd>
	<dt><code>value</code></dt>
		<dd>Value to be assigned to the variable (if not specified, logical <code>true</code> is assumed).</dd>
</dl>
<p>Refer to the <a href="#Internal_variables">Internal variables section</a> for
a list and a description of available variables. If <code>value</code> is not
specified, the variable is set to the logical <code>true</code>. Note that
not all variables can hold a logical values.</p>
<p>For boolean variables, there are several synonyms for <code>true</code>:
<code>true</code>, <code>on</code>, <code>yes</code>. Similarly the
synonyms for <code>false</code> are: <code>false</code>, <code>off</code>,
<code>no</code> and their prefixes.</p>
<h4>Example</h4>
<p>In the first example, we list all the variables:</p>
<pre class="cmd"><strong>[msim]</strong> set<span class="key">Enter</span>
Group                  Variable   Value
---------------------- ---------- ----------
Disassembling features
                       iaddr      on
                       iopc       off
                       icmt       on
                       iregch     on
                       ireg       2
Debugging features
                       trace      off
<strong>[msim]</strong> </pre>
<p>In the second example, we switch to trace mode:</p>
<pre class="cmd"><strong>[msim]</strong> s<span class="key">Enter</span>
<strong>[msim]</strong> set trace<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
    0  80401378    addiu a0, a0, 0x40      # 0x40=64, a0: 0xb7b8-&gt;0xf8
<strong>[msim]</strong> </pre>
<p>And in the third example, we set the type of register names:</p>
<pre class="cmd">[msim] set ireg = 2<span class="key">Enter</span>
[msim] id 0x00401330 1<span class="key">Enter</span>
    00401330    srl   v0, v0, 0x01
[msim] set ireg = 0<span class="key">Enter</span>
[msim] id 0x00401330 1<span class="key">Enter</span>
    00401330    srl   r2, r2, 0x01
[msim] </pre>

<h3>8.16. Unset <code>unset</code><a name="Unset"></a></h3> 
<h4>Synopsis</h4>
<p>Unset a logical internal variable.</p>
<h4>Syntax <code><strong>unset</strong> variable</code></h4>
<p>where</p>
<dl>
	<dt><code>variable</code></dt>
		<dd>Internal variable name to be unset.</dd>
</dl>
<p>Specified <code>variable</code> must hold a logical value. Refer to the
<a href="#Internal_variables">Internal variables section</a> for the list
and description of available variables.</p>
<h4>Example</h4>
<p>In the following example, the trace mode is switched off:</p>
<pre class="cmd"><strong>[msim]</strong> s<span class="key">Enter</span>
    0  80401334    addu  r5, r5, r2        # r5: 0x6512c4be->0x9754a5b8
<strong>[msim]</strong> unset trace<span class="key">Enter</span>
<strong>[msim]</strong> s<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<h3>8.17. Help <code>help</code><a name="Help"></a></h3> 
<h4>Synopsis</h4>
<p>Show the help for the specified system command or print the list of available system commands.</p>
<h4>Syntax <code><strong>help</strong> [command]</code></h4>
<p>where</p>
<dl>
	<dt><code>command</code></dt>
		<dd>Command name (if omited, the list of available system commands is printed).</dd>
</dl>

<h2>9. Devices<a name="Devices"></a></h2>

<p>MSIM can be configured with any number of device instances. Every device instance
has a given type. This section describes the available types of devices and their
properties.</p>

<h3>9.1. List of devices<a name="Devices_list"></a></h3>

<dl>
	<dt><a href="#dcpu">dcpu</a></dt>
		<dd>Processor (CPU)</dd>
	<dt><a href="#rwm">rwm</a></dt>
		<dd>Read/write memory</dd>
	<dt><a href="#rom">rom</a></dt>
		<dd>Read-only memory</dd>
	<dt><a href="#dprinter">dprinter</a></dt>
		<dd>Character output device (printer)</dd>
	<dt><a href="#dkeyboard">dkeyboard</a></dt>
		<dd>Character input device (keyboard)</dd>
	<dt><a href="#ddisk">ddisk</a></dt>
		<dd>Block device (hard disk)</dd>
	<dt><a href="#dorder">dorder</a></dt>
		<dd>Interprocessor communication device</dd>
	<dt><a href="#dtime">dtime</a></dt>
		<dd>Real-time clock</dd>
</dl>

<h3>9.2. Processor <code>dcpu</code><a name="dcpu"></a></h3>

<p>The <code>dcpu</code> device encapsulates a processor.</p>

<h4>Initialization parameters: <emph>none</emph></h4>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Display a help text for the specified command or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Display the processor configuration</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Display processor statistics</dd>
	<dt><code><strong>cp0d</strong> [rn]</code></dt>
		<dd>Dump contents of CP0 register(s)</dd>
	<dt><code><strong>tlbd</strong></code></dt>
		<dd>Dump the content of TLB</dd>
	<dt><code><strong>md</strong> saddr size</code></dt>
		<dd>Dump specified TLB mapped memory block</dd>
	<dt><code><strong>id</strong> sa cnt</code></dt>
		<dd>Dump instructions from specified TLB mapped memory</dd>
	<dt><code><strong>rd</strong></code></dt>
		<dd>Dump contents of CPU general registers</dd>
	<dt><code><strong>goto</strong> addr</code></dt>
		<dd>Go to address</dd>
	<dt><code><strong>break</strong> addr</code></dt>
		<dd>Add code breakpoint</dd>
	<dt><code><strong>bd</strong></code></dt>
		<dd>Dump configured code breakpoints</dd>
	<dt><code><strong>br</strong> addr</code></dt>
		<dd>Remove configured code breakpoint</dd>
</dl>

<h4>Examples</h4>
<p>Example of the <code>help</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> add dcpu mips1<span class="key">Enter</span>
<strong>[msim]</strong> mips1 help<span class="key">Enter</span>
Command & arguments  Description
-------------------- -------------------->
help [cmd]           Display this help text
info                 Display configuration information
stat                 Display processor statistics
cp0d [rn]            Dump contents of the coprocessor 0 register(s)
tlbd                 Dump content of TLB
md saddr size        Dump specified TLB mapped memory block
id saddr cnt         Dump instructions from specified TLB mapped memory
rd                   Dump contents of CPU general registers
goto addr            Go to address
break addr           Add code breakpoint
bd                   Dump code breakpoints
br addr              Remove code breakpoint
<strong>[msim] </strong>
</pre>

<p>Example of the <code>info</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> mips1 info<span class="key">Enter</span>
type:R4000.32
<strong>[msim]</strong> </pre>

<p>Example of the <code>stat</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> mips1 stat<span class="key">Enter</span>
cycles total:853037 in kernel:853037 in user:0 in stdby:0 tlb refill:0 
                      invalid: 0 modified:0 
                      interrupts 0:0 1:0 2:0 3:0 4:0 5:0 6:0 7:0
<strong>[msim]</strong> </pre>

<p>Example of the <code>cp0d</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> mips1 cp0d<span class="key">Enter</span>
  no name       hex dump  readable dump
  00 Index      0000002F  index: 2F res: 0 p: 0 
  01 Random     00000003  random: 03, res: 0000000
  02 EntryLo0   00000006  g: 0 v: 1 d: 1 c: 0 pfn: 000000 res: 0
  03 EntryLo1   00000000  g: 0 v: 0 d: 0 c: 0 pfn: 000000 res: 0
  04 Context    00000000  res: 0 badvpn2: 00000 ptebase: 000
  05 PageMask   001FE000  res1: 0000 mask: 0FF (1M) res2: 00
  06 Wired      00000001  wired: 1 res: 0000000
  08 BadVAddr   00000000  badvaddr: 00000000
  09 Count      0005A993  count: 5a993
  0a EntryHi    00000000  asid: 00 res: 0 vpn2: 00000
  0b Compare    0005ACDC  compare: 5acdc
  0c Status     00008001  ie: 1 exl: 0 erl: 0 ksu: 0 ux: 0 sx: 0 kx: 0
                          im: 80 de: 0 ce: 0 ch: 0 res1: 0 sr: 0 ts: 0
                          bev: 0 res2: 0 re: 0 fr: 0 rp: 0 cu: 0
  0d Cause      00000000  res1: 0 exccode: 00 res2: 0 ip: 00 res3: 00
                          ce: 0 res4: 0 bd: 0
  0e EPC        80401344  epc: 80401344
  0f PRId       00000200  rev: 00 imp: 02 res: 0000
  10 Config     00000000  k0: 0 cu: 0 db: 0 b: 0 dc: 0 ic: 0 res: 0 eb: 0
                          em: 0 be: 0 sm: 0 sc: 0 ew: 0 sw: 0 ss: 0 sb: 0
                          ep: 0 ec: 0 cm: 0
  11 LLAddr     00000000  lladdr: 00000000
  12 WatchLo    00000000  w: 0 r: 0 res: 0 paddr0: 00000000
  13 WatchHi    00000000  res: 00000000 paddr1: 0
  14 XContext
  1e ErrorEPC   00000000  errorepc: 00000000
<strong>[msim]</strong> </pre>

<p>Example of the <code>tlbd</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> mips1 tlbd<span class="key">Enter</span>
 [             general             ][    subp 0    ][    subp 1    ]
  no    vpn      mask        g asid  v d   pfn    c  v d   pfn    c
  00  00000000 FFE00000:1M   0  00   1 1 00000000 0  0 0 00000000 0
  01  00000000 FFE00000:1M   0  ff   1 1 00000000 0  0 0 00000000 0
<strong>[msim]</strong> </pre>

<p>Example of the <code>rd</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> mips1 rd<span class="key">Enter</span>
processor p0
   0 00000000   at 81000000   v0 62935B2A   v1 62312A00   a0 00000001
  a1 0000004A   a2 0000002E   a3 0000002D   t0 00000000   t1 00000000
  t2 00000000   t3 00000000   t4 00000000   t5 00000000   t6 00000000
  t7 00000000   s0 000D5427   s1 81000000   s2 805ACE55   s3 00000000
  s4 00000000   s5 00000000   s6 00000000   s7 00000000   t8 00000000
  t9 00000000   k0 00000000   k1 00000000   gp 00000000   sp 00013050
  fp 00000000   ra 80401308   pc 80401310   lo 40689065   hi 320BBCB7
<strong>[msim]</strong> </pre>

<h3>9.3. Read/write memory <code>rwm</code><a name="rwm"></a></h3>

<p>The <code>rwm</code> device represents a read/write random
access memory region. The memory block could be a general memory
or mapped from a file.</p>

<h4>Initialization parameters: <code>address</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Starting physical address of the memory block.</dd>
</dl>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified of a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print the device information (block address, size and type)</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics (none).</dd>
	<dt><code><strong>generic</strong> size</code></dt>
		<dd>Set the size of the memory block.</dd>
	<dt><code><strong>fmap</strong> filename</code></dt>
		<dd>Map the contents of the memory block from a file specified.</dd>
	<dt><code><strong>fill</strong> [value]</code></dt>
		<dd>Fill the memory block with zeros or the specified word value.</dd>
	<dt><code><strong>load</strong> filename</code></dt>
		<dd>Load the contents of the memory block from a file specified.</dd>
	<dt><code><strong>save</strong> filename</code></dt>
		<dd>Save the contents of the memory block to a file specified.</dd>
</dl>

<h4>Examples</h4>
<p>Example of the <code>info</code> command.</p>
<pre class="cmd"><strong>[msim]</strong> startmem info<span class="key">Enter</span>
start:0x1fc00000 size:1k type:mem
<strong>[msim]</strong> </pre>

<p>In the following example, the <code>add</code> command creates
a read/write memory region <code>mx</code> starting at the physical
address 0x00001000. The size of the region is set to 256&nbsp;KB
via the <code>generic</code> command.</p>

<pre class="cmd"><strong>[msim]</strong> add rwm mx 0x1000<span class="key">Enter</span>
<strong>[msim]</strong> mx generic 256k<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<p>The content of the read-write memory can be changed as expected
from the code running in the simulator:</p>

<pre class="c"><span class="lnr"> 1 </span><span class="keyword">volatile char</span> *p = (<span class="keyword">char</span> * ) 0x1000;  <span class="comment">/* assume 1:1 identity memory mapping */</span>
<span class="lnr"> 2 </span><span class="keyword">char</span> c = *p;  <span class="comment">/* c contains a byte value read from the address 0x00001000 */</span>
<span class="lnr"> 3 </span>*p += 1;
<span class="lnr"> 4 </span><span class="keyword">char</span> d = *p;  <span class="comment">/* d contains a byte value read from the address 0x00001001 */</span></pre>

<h3>9.4. Read-only memory <code>rom</code><a name="rom"></a></h3>

<p>The <code>rom</code> device represents a read-only random access memory region.</p>

<h4>Initialization parameters: <code>address</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Starting physical address of the memory block.</dd>
</dl>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print the device information (block address, size and type)</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics (none).</dd>
	<dt><code><strong>generic</strong> size</code></dt>
		<dd>Set the size of the memory block.</dd>
	<dt><code><strong>fmap</strong> filename</code></dt>
		<dd>Map the contents of the memory block from a file specified.</dd>
	<dt><code><strong>fill</strong> [value]</code></dt>
		<dd>Fill the memory block with zeros or the specified word value.</dd>
	<dt><code><strong>load</strong> filename</code></dt>
		<dd>Load the contents of the memory block from a file specified.</dd>
	<dt><code><strong>save</strong> filename</code></dt>
		<dd>Save the contents of the memory block to a file specified.</dd>
</dl>

<h4>Examples</h4>

<p>In the following example, the <code>add</code> command creates
a read-only memory region <code>mx</code> starting at the physical
address 0x00001000. The size of the region is set to 256&nbsp;KB
via the <code>generic</code> command.</p>

<pre class="cmd"><strong>[msim]</strong> add rom mx 0x1000<span class="key">Enter</span>
<strong>[msim]</strong> mx generic 256k<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<p>All attempts to write into read-only memory are silently ignored.</p>

<pre class="c"><span class="lnr"> 1 </span><span class="keyword">volatile char</span> *p = (<span class="keyword">char</span> * ) 0x1000;  <span class="comment">/* assume 1:1 identity memory mapping */</span>
<span class="lnr"> 2 </span><span class="keyword">char</span> c = *p;  <span class="comment">/* c contains a byte value read from the address 0x00001000 */</span>
<span class="lnr"> 3 </span>*p = ~c;      <span class="comment">/* write access is ignored */</span>
<span class="lnr"> 4 </span><span class="keyword">char</span> d = *p;  <span class="comment">/* c == d */</span></pre>

<h3>9.5. Character output device <code>dprinter</code><a name="dprinter"></a></h3>

<p>The character output device simulates a simple character printer or a serial console.</p>

<h4>Initialization parameters: <code>address</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Physical address of the printer register</dd>
</dl>

<h4>Registers</h4>
<table>
	<caption><code>dprinter</code> programming registers</caption>
	<tr>
		<th>Offset</th><th>Name</th><th>Operation</th><th>Description</th>
	</tr>
	<tr>
		<td rowspan="2">+0</td>
		<td rowspan="2">character</td>
		<td>read</td>
		<td>(ignored)</td>
	</tr>
	<tr>
		<td>write</td>
		<td>character to be printed on the standard output of MSIM</td>
	</tr>
</table>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help text to the specified command or a list of allowed commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print basic configuration information (register address).</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print printer statistics (number of characters printed).</dd>
	<dt><code><strong>redir</strong> filename</code></dt>
		<dd>Redirect the output to the file specified.</dd>
	<dt><code><strong>stdout</strong></code></dt>
		<dd>Redirect the output to the standard output.</dd>
</dl>

<h4>Example</h4>

<p>Example of the <code>info</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> add dprinter printer 0x10000000<span class="key">Enter</span>
<strong>[msim]</strong> printer info<span class="key">Enter</span>
address:0x01000000
<strong>[msim]</strong> </pre>

<p>Example of the <code>stat</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> printer stat<span class="key">Enter</span>
count:11385
<strong>[msim]</strong> </pre>

<p>Example of a simple output implementation in the MIPS code:</p>
<pre class="c"><span class="lnr">  1 </span><span class="comment">/* VIDEOADDR is the address of the memory-mapped register of dprinter.</span>
<span class="lnr">  2 </span><span class="comment"> * It has to correspond with the definition in the configuration file. */</span>
<span class="lnr">  3 </span><span class="preproc">#define VIDEOADDR 0x10000000</span>
<span class="lnr">  4 </span>
<span class="lnr">  5 </span><span class="comment">/ * Write one character on the screen. */</span>
<span class="lnr">  6 </span><span class="keyword">void</span> putchar(<span class="keyword">char</span> c)
<span class="lnr">  7 </span>{
<span class="lnr">  8 </span>    *((<span class="keyword">volatile char</span> *) VIDEOADDR) = c;
<span class="lnr">  9 </span>}
<span class="lnr"> 10 </span>
<span class="lnr"> 11 </span><span class="comment">/* Write a NULL-terminated string on the screen. */</span>
<span class="lnr"> 12 </span><span class="keyword">void</span> putstring(<span class="keyword">char</span>* c)
<span class="lnr"> 13 </span>{
<span class="lnr"> 14 </span>    <span class="keyword">while</span> (*c)
<span class="lnr"> 15 </span>        *((<span class="keyword">volatile char</span> *) VIDEOADDR) = *c++;
<span class="lnr"> 16 </span>}
</pre>

<h3>9.6. Character input device <code>dkeyboard</code><a name="dkeyboard"></a></h3>
<p>The character input device simulates a keyboard connected to the machine.
When a key is pressed, the keyboard asserts an interrupt and the ASCII key code
can be read from the memory-mapped register. Any read operation on the register
automatically deasserts the pending interrupt.</p>

<h4>Initialization parameters: <code>address</code> <code>intno</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Physical address of the keyboard register.</dd>
	<dt><code>intno</code></dt>
		<dd>Interrupt number which will be asserted on keypress.</dd>
</dl>

<h4>Registers</h4>
<table>
	<caption><code>dkeyboard</code> programming registers</caption>
	<tr>
		<th>Offset</th>
		<th>Name</th>
		<th>Operation</th>
		<th>Description</th>
	</tr>
	<tr>
		<td rowspan="2">+0</td>
		<td rowspan="2">keycode</td>
		<td>read</td>
		<td>key code of the pressed key (any read operation deasserts the pending interrupt)</td>
	</tr>
	<tr>
		<td>write</td>
		<td>(ignored)</td>
	</tr>
</table>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print configuration information (register address, interrupt number and a keycode pending).</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics (number of interrupts, pressed keys and overrun keys).</dd>
	<dt><code><strong>gen</strong> keycode</code></dt>
		<dd>Synthetically generates a key press event.</dd>
</dl>

<h4>Examples</h4>

<p>The following command adds a keyboard <code>kb</code> to the machine. The keyboard register is
mapped physical address 0x10000000.</p>
<pre class="cmd"><strong>[msim]</strong>add dkeyboard kb 0x1000000<span class="key">Enter</span>
<strong>[msim]</strong> </pre>

<p>Example of the <code>info</code> command:</p>
<pre class="cmd"><strong>[msim]</strong> kb info<span class="key">Enter</span>
address:0x10000000 intno:3 regs(key:0x00 ig:0)
<strong>[msim]</strong> </pre>

<p>Example of the <code>stat</code> command.</p>
<pre class="cmd"><strong>[msim]</strong> kb stat<span class="key">Enter</span>
intrc:11 keycount:11 overrun:0
<strong>[msim]</strong> </pre>

<h3>9.7. Block device <code>ddisk</code><a name="ddisk"></a></h3>

<p>The block device simulates a simple hard disk with DMA capabilities.
The device can be accesses by linearly ordered 512&nbsp;B-sized sectors.
The device allows to access the contents of a file from the host system
running MSIM.</p>

<h4>Initialization parameters: <code>address</code> <code>intno</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Physical address of the hard disk register.</dd>
	<dt><code>intno</code></dt>
		<dd>DMA Interrupt number.</dd>
</dl>

<h4>Registers</h4>
<table>
	<caption><code>ddisk</code> programming registers</caption>
	<tr>
		<th>Offset</th>
		<th>Name</th>
		<th>Operation</th>
		<th>Description</th>
	</tr>
	<tr>
		<td rowspan="2">+0</td>
		<td rowspan="2">DMA buffer address</td>
		<td>read</td>
		<td>get the current physical address of the DMA buffer</td>
	</tr>
	<tr>
		<td>write</td>
		<td>set the physical address of the DMA buffer
			<ul>
				<li>performing a <emph>read operation</emph> will store the data read from the block device to this buffer</li>
				<li>performing a <emph>write operation</emph> will fetch the data to be written to the block device from this buffer</li>
			</ul></td>
	</tr>
	<tr>
		<td rowspan="2">+4</td>
		<td rowspan="2">sector number</td>
		<td>read</td>
		<td>get the current sector number</td>
	</tr>
	<tr>
		<td>write</td>
		<td>set the sector number which be used by the next <emph>read</emph> or <emph>write operation</emph></td>
	</tr>
	<tr>
		<td rowspan="2">+8</td>
		<td rowspan="2">status/command</td>
		<td>read</td>
		<td><p>get a bitfield representing the current status of the device:</p>
			<table class="bitfield">
				<tr>
					<th>31</th>
					<th>30</th>
					<th>29</th>
					<th>28</th>
					<th>27</th>
					<th>26</th>
					<th>25</th>
					<th>24</th>
					<th>23</th>
					<th>22</th>
					<th>21</th>
					<th>20</th>
					<th>19</th>
					<th>18</th>
					<th>17</th>
					<th>16</th>
					<th>15</th>
					<th>14</th>
					<th>13</th>
					<th>12</th>
					<th>11</th>
					<th>10</th>
					<th>9</th>
					<th>8</th>
					<th>7</th>
					<th>6</th>
					<th>5</th>
					<th>4</th>
					<th>3</th>
					<th>2</th>
					<th>1</th>
					<th>0</th>
				</tr>
				<tr>
					<td colspan="28"><code>r1</code></td>
					<td><code>e</code></td>
					<td><code>i</code></td>
					<td colspan="2"><code>r0</code></td>
				</tr>
			</table>
			<p>where the meaning of the fields read is</p>
			<dl>
				<dt><code>r1</code></dt>
					<dd>(reserved)</dd>
				<dt><code>e</code></dt>
					<dd>0: no error<br />
						1: the previous operation caused an error</dd>
				<dt><code>i</code></dt>
					<dd>0: no DMA interrupt pending<br />
						1: DMA interrupt pending</dd>
				<dt><code>r0</code></dt>
					<dd>(reserved)</dd>
			</dl></td>
	</tr>
	<tr>
		<td>write</td>
		<td><p>set a bitfield representing requested operation:</p>
			<table class="bitfield">
				<tr>
					<th>31</th>
					<th>30</th>
					<th>29</th>
					<th>28</th>
					<th>27</th>
					<th>26</th>
					<th>25</th>
					<th>24</th>
					<th>23</th>
					<th>22</th>
					<th>21</th>
					<th>20</th>
					<th>19</th>
					<th>18</th>
					<th>17</th>
					<th>16</th>
					<th>15</th>
					<th>14</th>
					<th>13</th>
					<th>12</th>
					<th>11</th>
					<th>10</th>
					<th>9</th>
					<th>8</th>
					<th>7</th>
					<th>6</th>
					<th>5</th>
					<th>4</th>
					<th>3</th>
					<th>2</th>
					<th>1</th>
					<th>0</th>
				</tr>
				<tr>
					<td colspan="29"><code>r0</code></td>
					<td><code>i</code></td>
					<td><code>w</code></td>
					<td><code>r</code></td>
				</tr>
			</table>
			<p>where the meaning of the fields read is</p>
			<dl>
				<dt><code>r0</code></dt>
					<dd>(reserved)</dd>
				<dt><code>i</code></dt>
					<dd>if set to 1 then the DMA interrupt is deasserted</dd>
				<dt><code>w</code></dt>
					<dd>if set to 1 then a <emph>write operation</emph> is initiated (fetching the data from the DMA buffer and writing it to the sector set)</dd>
				<dt><code>r</code></dt>
					<dd>if set to 1 then a <emph>read operation</emph> is initiated (reading the data from the sector set and storing it to the DMA buffer)</dd>
			</dl>
			<p>(initiating both read and write operation at the same time results with an error)</p></td>
	</tr>
	<tr>
		<td rowspan="2">+12</td>
		<td rowspan="2">disk size</td>
		<td>read</td>
		<td>get the size of the block device in bytes</td>
	</tr>
	<tr>
		<td>write</td>
		<td>(ignored)</td>
	</tr>
</table>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print the device information.</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics.</dd>
	<dt><code><strong>generic</strong> size</code></dt>
		<dd>Allocate a block device of the given size from host memory.</dd>
	<dt><code><strong>fmap</strong> name</code></dt>
		<dd>Map the block device to a file specified.</dd>
	<dt><code><strong>fill</strong> [value]</code></dt>
		<dd>Fill the block device with zeros or the specified word value.</dd>
	<dt><code><strong>load</strong> fname</code></dt>
		<dd>Load the contents of the block device from a file specified.</dd>
	<dt><code><strong>save</strong> fname</code></dt>
		<dd>Save the contents of the block device to a file specified.</dd>
</dl>

<h3>9.8. Interprocessor communication device <code>dorder</code><a name="dorder"></a></h3>

<p>This device allows to obtain a processor serial number in a multiprocessor
configuration and asserting an interprocessor interrupt on a specified processor.</p>

<h4>Initialization parameters: <code>address</code> <code>intno</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Physical address of the device register.</dd>
	<dt><code>intno</code></dt>
		<dd>Interprocessor communication interrupt number.</dd>
</dl>

<h4>Registers</h4>
<table>
	<caption><code>dorder</code> programming registers</caption>
	<tr>
		<th>Offset</td>
		<th>Name</th>
		<th>Operation</th>
		<th>Description</th>
	</tr>
	<tr>
		<td rowspan="2">+0</td>
		<td>processor number</td>
		<td>read</td>
		<td>get the unique number of the processor performing the read operation</td>
	</tr>
	<tr>
		<td>interrupt up</td>
		<td>write</td>
		<td>setting any bit causes an interrupt pending on the processor specified by the bit index</td>
	</tr>
	<tr>
		<td rowspan="2">+4</td>
		<td rowspan="2">interrupt down</td>
		<td>read</td>
		<td>(ignored)</td>
	</tr>
	<tr>
		<td>write</td>
		<td>setting any bit acknowledges an interrupt pending on the processor specified by the bit index (the interrupt is deasserted)</td>
	</tr>
</table>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print configuration information (register address and interrupt number).</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics (number of interrupts).</dd>
	<dt><code><strong>synch</strong> mask</code></dt>
		<dd>Simulate a write operation on the &quot;interrupt up&quot; register.</dd>
</dl>

<h4>Examples</h4>
<p>The following example adds a new <code>dorder</code> device named <code>order</code> and maps its register
on the physical address 0x10000000.</p>
<pre class="cmd"><strong>[msim]</strong>add dorder order 0x1000000<span class="key">Enter</span>
<strong>[msim]</strong> </pre>
<p>Simple usage in MIPS code:</p>
<pre class="c"><span class="lnr">  1 </span><span class="comment">/* ORDER is the address of the memory-mapped register of dorder.</span>
<span class="lnr">  2 </span><span class="comment"> * It has to correspond with the definition in the configuration file. */</span>
<span class="lnr">  3 </span><span class="preproc">#define ORDER 0x10000000</span>
<span class="lnr">  4 </span>
<span class="lnr">  5 </span><span class="comment">/* Get current CPU identification. */</span>
<span class="lnr">  6 </span><span class="keyword">unsigned int</span> cpu_id(<span class="keyword">void</span>)
<span class="lnr">  7 </span>{
<span class="lnr">  8 </span>    <span class="keyword">return</span> *((<span class="keyword">volatile unsigned int</span> *) ORDER);
<span class="lnr">  9 </span>}
<span class="lnr"> 10 </span>
<span class="lnr"> 11 </span><span class="comment">/* Send interprocessor interrupt to the given CPU */</span>
<span class="lnr"> 12 </span><span class="keyword">void</span> cpu_send_ipi(<span class="keyword">unsigned int</span> id)
<span class="lnr"> 13 </span>{
<span class="lnr"> 14 </span>    *((<span class="keyword">volatile unsigned int</span> *) ORDER) = (1 &lt;&lt; id);
<span class="lnr"> 15 </span>}
<span class="lnr"> 16 </span>
<span class="lnr"> 17 </span><span class="comment">/* Send interprocessor interrupt to all CPUs */</span>
<span class="lnr"> 18 </span><span class="keyword">void</span> cpu_send_ipi_all(<span class="keyword">void</span>)
<span class="lnr"> 19 </span>{
<span class="lnr"> 20 </span>    *((<span class="keyword">volatile unsigned int</span> *) ORDER) = 0xffffffff;
<span class="lnr"> 21 </span>}
<span class="lnr"> 22 </span>
<span class="lnr"> 23 </span><span class="comment">/* Deassert interprocessor interrupt for the given CPU */</span>
<span class="lnr"> 24 </span><span class="keyword">void</span> cpu_ack_ipi(<span class="keyword">unsigned int</span> id)
<span class="lnr"> 25 </span>{
<span class="lnr"> 26 </span>    *((<span class="keyword">volatile unsigned int</span> *) (ORDER + 4)) = (1 &lt;&lt; id);
<span class="lnr"> 27 </span>}</pre>

<h3>9.9. Real-time clock <code>dtime</code><a name="dtime"></a></h3>
<p>This device passes the system time of the host machine to the simulated environment.</p>

<h4>Initialization parameters: <code>address</code></h4>
<p>where</p>
<dl>
	<dt><code>address</code></dt>
		<dd>Physical address of the device register.</dd>
</dl>

<h4>Registers</h4>
<table>
	<caption><code>dtime</code> programming registers</caption>
	<tr>
		<th>Offset</th>
		<th>Name</th>
		<th>Operation</th>
		<th>Description</th>
	</tr>
	<tr>
		<td rowspan="2">+0</td>
		<td rowspan="2">time</td>
		<td>read</td>
		<td>number of seconds since the epoch, i.e. 00:00:00 January 1st 1970 UTC (equivalent to the POSIX <code>time()</code> function)</td>
	</tr>
	<tr>
		<td>write</td>
		<td>(ignored)</td>
	</tr>
</table>

<h4>Commands</h4>
<dl>
	<dt><code><strong>help</strong> [cmd]</code></dt>
		<dd>Print a help on the command specified or a list of available commands.</dd>
	<dt><code><strong>info</strong></code></dt>
		<dd>Print configuration information (assigned register address).</dd>
	<dt><code><strong>stat</strong></code></dt>
		<dd>Print device statistics (none).</dd>
</dl>

<h2>10. Special instructions<a name="Special_instructions"></a></h2>
<p>To further improve the ease of debugging the code running in MSIM,
there are several non-standard MIPS instructions available.
This allows to change the behaviour of the simulator exactly at the
place of code required, with only a minimal influence to the debugged code.</p>

<dl>
	<dt><a href="#dtrc">DTRC</a></dt>
		<dd>Enable the trace mode.</dd>
	<dt><a href="#dtro">DTRO</a></dt>
		<dd>Disable the trace mode.</dd>
	<dt><a href="#dint">DINT</a></dt>
		<dd>Enable the interactive mode.</dd>
	<dt><a href="#drv">DRV</a></dt>
		<dd>Dump the content of all general registers to the screen.</dd>
	<dt><a href="#dhlt">DHLT</a></dt>
		<dd>Halt the simulation.</dd>
	<dt><a href="#dval">DVAL</a></dt>
		<dd>Dump the <code><strong>a0</strong></code> general register to the screen.</dd>
</dl>

<h4>Example</h4>
<p>The following example shows an implementation in GCC:</p>
<pre class="c"><span class="lnr"> 1 </span><span class="preproc">#define ___trace_on()   asm volatile ( &quot;.word 0x39\n&quot;);</span>
<span class="lnr"> 2 </span><span class="preproc">#define ___trace_off()  asm volatile ( &quot;.word 0x3d\n&quot;);</span>
<span class="lnr"> 3 </span><span class="preproc">#define ___reg_dump()   asm volatile ( &quot;.word 0x37\n&quot;);</span>
<span class="lnr"> 4 </span><span class="preproc">#define ___halt()       asm volatile ( &quot;.word 0x28\n&quot;);</span>
<span class="lnr"> 5 </span><span class="preproc">#define ___val(i)       asm volatile ( &quot;.word 0x35\n&quot; :: &quot;r&quot; (i));</span></pre>

<h3>10.1. Trace on <code>DTRC</code><a name="dtrc"></a></h3>
<p>Enable the trace mode. Together with <a href="#dtro">DTRO</a> instruction, DTRC is useful to show a part of executed code.</p>
<h4>Opcode: <code><strong>0x39</strong></code></h4>

<h3>10.2. Trace off <code>DTRO</code><a name="dtro"></a></h3>
<p>Disable the trace mode. Together with <a href="#dtrc">DTRC</a> instruction, DTRO is useful to show a part of executed code.</p>
<h4>Opcode: <code><strong>0x3d</strong></code></h4>

<h3>10.3. Interactive mode on <code>DINT</code><a name="dint"></a></h3>
<p>Enable the interactive mode. The command line is activated immediately.</p>
<h4>Opcode: <code><strong>0x29</strong></code></h4>

<h3>10.4. Register view <code>DRV</code><a name="drv"></a></h3>
<p>The instruction dumps the content of all the general registers to the screen.</p>
<h4>Opcode: <code><strong>0x37</strong></code></h4>

<h3>10.5. Halt machine <code>DHLT</code><a name="dhlt"></a></h3>
<p>Halt the machine as well as the simulation immediately. Useful also as the power off feature.</p>
<h4>Opcode: <code><strong>0x28</strong></code></h4>

<h3>10.6. View value <code>DVAL</code><a name="dval"></a></h3>
<p>Print the content of the <code>a0</code> (<code>r4</code>) register.
The instruction can be used to instantly print a value of a variable.</p>
<h4>Opcode: <code><strong>0x35</strong></code></h4>

<h2>11. GDB support<a name="GDB_support"></a></h2>

<p>The GDB support is experimental in version 1.3. The feature will be described
in more detail after it will be matured.</p>
</body>
</html>
